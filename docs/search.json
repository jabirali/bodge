[
  {
    "objectID": "TUTORIAL.html",
    "href": "TUTORIAL.html",
    "title": "Bodge tutorial",
    "section": "",
    "text": "Bodge has been uploaded to the Python Package Index (PyPI). This means that if you have a recent version of Python and Pip installed on your system, installing this package should be as simple as:\npip install bodge\nFor more installation alternatives, please see the README on GitHub.\nThe next two sections below discusses in some detail how Bodge has been designed and implemented. If you just want to use the package, feel free to skip directly to the section Getting started below."
  },
  {
    "objectID": "TUTORIAL.html#normal-metal-wire",
    "href": "TUTORIAL.html#normal-metal-wire",
    "title": "Bodge tutorial",
    "section": "Normal-metal wire",
    "text": "Normal-metal wire\nLet us start with a simple case: Calculating the local density of states (LDOS) in the middle of a long normal-metal wire. Such a wire can be considered as an \\(L_x \\times L_y \\times L_z\\) cubic lattice where \\(L_x \\gg  L_y = L_z = 1\\). A normal metal is generally modeled as having only a chemical potential \\(\\mu\\) and a hopping amplitude \\(t.\\) The following code performs the required calculations:\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfrom bodge import *\n\n# Model parameters\nLx = 512\nLy = 1\nLz = 1\n\nt = 1\nμ = 1.5 * t\n\n# Construct the Hamiltonian\nlattice = CubicLattice((Lx, Ly, Lz))\nsystem = Hamiltonian(lattice)\n\nwith system as (H, _):\n    for i in lattice.sites():\n        H[i, i] = -μ * σ0\n    for i, j in lattice.bonds():\n        H[i, j] = -t * σ0\n\n# Calculate the central density of states.\ni = (Lx//2, Ly//2, Lz//2)\nω = np.linspace(-5 * t, 5 * t, 101)\nρ = system.ldos(i, ω)\n\n# Plot the density of states at the system center.\nplt.figure()\nplt.xlabel(\"Quasiparticle energi ω/t\")\nplt.ylabel(\"Density of states ρ(ω)\")\nplt.plot(ω, ρ)\n\n\n\n\n\n\n\n\nSome things I want to elaborate on regarding this example:\n\nBodge implements a “context manager” for filling out terms H[i, j] in the Hamiltonian. So every time you want to update the Hamiltonian, you write a with system as ...: block, after which you can pretend that H[i, j] simply indexes a large Hamiltonian matrix. Once you exit the with block, Bodge takes care of the gory details: Transferring the terms in the Hamiltonian to the underlying sparse matrix, ensuring that Hermitian and particle-hole symmetries are satisfied, and complaining loudly if the Hamiltonian is non-Hermitian.\nNote that everything you insert using H[i, j] = ... must be a \\(2\\times2\\) complex matrix, which is most easily done by multiplying coefficients with an identity matrix σ0, a Pauli matrix σ1, σ2, σ3, or their complex equivalents jσ0 = 1j * σ0 etc. These symbols are automatically imported when you do from bodge import *. I like to code using Greek letters to keep the notation as close to a physics paper as possible, and typing Greek letters is usually straight-forward.1 But if you don’t want to code using Unicode symbols, that is completely fine as well: Bodge doesn’t require Unicode anywhere. Every object exported by the library has an ASCII version, so you can e.g. type sigma0 and jsigma2 instead of σ0 and jσ2 if you prefer that.\nWhen instantiating the matrix, we can use lattice.sites() and lattice.bonds() to iterate over the whole lattice. In this case, we have kept it simple, and only have one type of on-site term and one type of hopping term, but Bodge itself is very flexible. You can e.g. use lattice.bonds(axis=0) to iterate over only bonds that point along the 0th axis (x axis), which is useful if you need different hopping terms in different directions. Moreover, each coordinate i above is simply a tuple (x_i, y_i, z_i) where \\(0 \\leq x_i &lt; L_x\\) and so on. Thus, you can easily use some if tests on these coordinates to implement interfaces between different materials, or a function like np.cos(ν * i[0]) to implement magnetic textures, etc.\nEvery Hamiltonian object must be instantiated on a Lattice object. Currently, only one lattice is implemented, namely the CubicLattice illustrated above. However, Bodge itself is designed to be completely independent of the lattice structure, and can easily be used with say a triangular or hexagonal lattice if you want: To do this, you only need to define your own subclass of Lattice where you implement methods .sites() and .bonds() that can be used to iterate over all the atomic sites and nearest-neighbor bonds in the lattice. The best way to learn how to do this, is to look at the CubicLattice code.\nThe system.ldos method implements an efficient sparse matrix algorithm to obtain the local density of states at only a single site \\(i\\) – in this case, the center of the system. The algorithm implemented is explained in detail in Appendix A of this paper, and is essentially a simplified version of the algorithm from this paper.\nIf you wish, you can diagonalize the system instead using E, X = system.diagonalize(), and then use the eigenvalues E[n] and corresponding eigenvectors X[n,:,:] to obtain the density of states. This method uses dense matrices (NumPy arrays), and is significantly slower for large systems."
  },
  {
    "objectID": "TUTORIAL.html#bcs-superconductor",
    "href": "TUTORIAL.html#bcs-superconductor",
    "title": "Bodge tutorial",
    "section": "BCS Superconductor",
    "text": "BCS Superconductor\nLet’s consider a small two-dimensional superconductor: Specifically, a \\(32\\times32\\) atom \\(s\\)-wave singlet superconductor.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfrom bodge import *\n\n# Model parameters\nLx = 101\nLy = 101\n\nt = 1\nμ = -3 * t\nΔs = 0.2 * t\n\n# Construct the Hamiltonian\nlattice = CubicLattice((Lx, Ly, 1))\nsystem = Hamiltonian(lattice)\n\nwith system as (H, Δ):\n    for i in lattice.sites():\n        H[i, i] = -μ * σ0\n        Δ[i, i] = -Δs * jσ2\n    for i, j in lattice.bonds():\n        H[i, j] = -t * σ0\n\n# Calculate the central density of states for energies near the gap.\ni = (Lx//2, Ly//2, 0)\nω = np.linspace(-1.5 * Δs, 1.5 * Δs, 101)\nρ = system.ldos(i, ω)\n\n# Plot the density of states at the system center.\nplt.plot(ω, ρ)\nplt.xlabel(\"Quasiparticle energi ω/t\")\nplt.ylabel(\"Density of states ρ(ω)\")\n\nText(0, 0.5, 'Density of states ρ(ω)')\n\n\n\n\n\n\n\n\n\nE, v = system.diagonalize()\nThis section is still under construction."
  },
  {
    "objectID": "TUTORIAL.html#superconductivity",
    "href": "TUTORIAL.html#superconductivity",
    "title": "Bodge tutorial",
    "section": "Superconductivity",
    "text": "Superconductivity"
  },
  {
    "objectID": "TUTORIAL.html#non-rectangular-lattices",
    "href": "TUTORIAL.html#non-rectangular-lattices",
    "title": "Bodge tutorial",
    "section": "Non-rectangular lattices",
    "text": "Non-rectangular lattices\nAll the examples above assume that we have a rectangular lattice, i.e. that the lattice is an instance of CubicLattice. However, this is not required to use Bodge itself, it is just the only lattice type implemented so far. If you wish to study other lattices – e.g. triangular or hexagonal lattices – the only thing you need to do is to create a subclass of Lattice, where you implement your own methods .sites(), .bonds(), and .edges() which can be used to iterate through your custom lattice."
  },
  {
    "objectID": "TUTORIAL.html#footnotes",
    "href": "TUTORIAL.html#footnotes",
    "title": "Bodge tutorial",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nExamples: Vim has built-in “digraphs” where you can press &lt;C-k&gt;s* in insert mode to type σ. Emacs has a built-in “TeX input method”, which means that after pressing C-\\ you can type \\sigma to insert the symbol σ. Most other editors code have third-party plugins for this, e.g. Unicode Latex for VSCode. Another option is to use an OS-wide snippet expander (e.g. TextExpander), which you can setup to e.g. convert ;s to σ in any application. There are many alternatives!↩︎"
  }
]