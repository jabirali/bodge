[
  {
    "objectID": "tutorial.html",
    "href": "tutorial.html",
    "title": "Bodge tutorial",
    "section": "",
    "text": "Bodge has been uploaded to the Python Package Index (PyPI). This means that if you have a recent version of Python and Pip installed on your system, installing this package should be as simple as:\npip install bodge\nFor more installation alternatives, please see the README on GitHub."
  },
  {
    "objectID": "tutorial.html#normal-metal",
    "href": "tutorial.html#normal-metal",
    "title": "Bodge tutorial",
    "section": "Normal metal",
    "text": "Normal metal\nThe simplest electronic tight-binding model is arguably a one-dimensional normal-metal wire. As an introductory example, let’s therefore try to calculate the local density of states (LDOS) in the middle of such a wire.\nA wire can be considered an \\(L_x \\times L_y \\times L_z\\) cubic lattice in the limit that \\(L_x \\gg  L_y = L_z\\). The tight-binding model for normal metals contains only a chemical potential \\(\\mu\\) and a hopping amplitude \\(t\\), and is often written as: \\[\\mathcal{H} = -\\mu \\sum_{i\\sigma} c^\\dagger_{i\\sigma} c_{i\\sigma} -t \\sum_{\\langle ij \\rangle \\sigma} c^\\dagger_{i\\sigma} c_{j\\sigma}.\\] Bodge however requires that it be written in the form: \\[\\mathcal{H} = \\sum_{i\\sigma\\sigma'} c^\\dagger_{i\\sigma} (H_{ii})_{\\sigma\\sigma'} c_{i\\sigma'} + \\sum_{\\langle ij \\rangle \\sigma\\sigma'} c^\\dagger_{i\\sigma} (H_{ij})_{\\sigma\\sigma'} c_{j\\sigma'},\\] where \\(H_{ii}\\) and \\(H_{ij}\\) are \\(2\\times2\\) matrices that represents spin dependence. From this, we basically see that the system above can be summarized as: \\[H_{ij} = \\begin{cases} -\\mu\\sigma_0 & \\text{if $i = j$,} \\\\ -t\\sigma_0 & \\text{otherwise.} \\end{cases}\\] This is precisely what we need to tell Bodge to create the desired Hamiltonian. The following code performs the calculations we want:\n\n# Standard imports in every numerical Python code\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Bodge is designed to be imported in this way, but you can\n# of course `import bodge as bdg` if you really want to\nfrom bodge import *\n\n# Define the tight-binding model parameters\nLx = 512\nLy = 1\nLz = 1\n\nt = 1\nμ = 1.5 * t\n\n# Construct the Hamiltonian\nlattice = CubicLattice((Lx, Ly, Lz))\nsystem = Hamiltonian(lattice)\n\nwith system as (H, _):\n    for i in lattice.sites():\n        H[i, i] = -μ * σ0\n    for i, j in lattice.bonds():\n        H[i, j] = -t * σ0\n\n# If you need the Hamiltonian matrix itself, you could use:\n# H = system.matrix()  # NumPy dense array\n# H = system.matrix(format=\"csr\")  # SciPy sparse matrix\n\n# Calculate the central density of states\ni = (Lx//2, Ly//2, Lz//2)\nω = np.linspace(-μ-4*t, -μ+4*t, 101)\nρ = system.ldos(i, ω)\n\n# Plot the density of states at the system center\nplt.figure()\nplt.xlabel(\"Quasiparticle energy ω/t\")\nplt.ylabel(\"Density of states ρ(ω)\")\nplt.plot(ω, ρ)\n\n\n\n\n\n\n\n\nSome things I want to elaborate on in this example:\n\nBodge implements a “context manager” for filling out terms H[i, j] in the Hamiltonian. So every time you want to update the Hamiltonian, you write a with system as ...: block, after which you can pretend that H[i, j] simply indexes a large Hamiltonian matrix. Once you exit the with block, Bodge takes care of the gory details: Transferring the terms in the Hamiltonian to the underlying sparse matrix, ensuring that Hermitian and particle-hole symmetries are satisfied, and complaining loudly if the Hamiltonian is non-Hermitian. As mentioned in the comments, you can at this point use the system.matrix() method to obtain the constructed Hamiltonian matrix if you need it.\nNote that everything you insert using H[i, j] = ... must be a \\(2\\times2\\) complex matrix, which is most easily done by multiplying coefficients with one of the Pauli matrices σ0, σ1, σ2, σ3, or their complex equivalents jσ0 = 1j * σ0 etc. These symbols are automatically imported when you do from bodge import *. I like to code using Greek letters to use the same notation in papers and code – Python supports Unicode variable names, and typing them is usually straight-forward.1 But if you don’t want Unicode symbols, that is completely fine as well: Bodge doesn’t require Unicode anywhere. Every object exported by the library has an ASCII version, so you can e.g. type sigma0 and jsigma2 instead of σ0 and jσ2 if you prefer that.\nWhen filling out the matrix, we can use lattice.sites() and lattice.bonds() to iterate over the whole lattice. In this case, we have kept it simple, and only have one type of on-site term and one type of hopping term, but Bodge itself is very flexible. You can e.g. use lattice.bonds(axis=0) to iterate over only bonds that point along the 0th axis (x axis), which is useful if you need different hopping terms in different directions. Moreover, each coordinate \\(i\\) above is simply a tuple \\((x_i, y_i, z_i)\\) where \\(0 \\leq x_i &lt; L_x\\) and so on. Thus, you can use e.g. if i[0] &lt; Lx/2: to implement a sharp interface between different materials, or a function call like np.sin(np.pi*i[0]/Lx) to implement a field that varies smoothly throughout the lattice.\nThe system.ldos method implements an efficient sparse matrix algorithm to obtain the local density of states at a single site \\(i\\). The algorithm implemented is explained in detail in Appendix A of this paper, and is essentially a simplified version of the algorithm from this paper. You could alternatively diagonalize the Hamiltonian using E, X = system.diagonalize(), and then use the eigenvalues E[n] and corresponding eigenvectors X[n,:,:] to obtain the density of states as described in e.g. Zhu’s textbook. However, this approach uses dense matrices (NumPy arrays), and is therefore significantly slower for large systems. I’d therefore recommend researching whether you can use a sparse matrix algorithm before you diagonalize large matrices."
  },
  {
    "objectID": "tutorial.html#conventional-superconductor",
    "href": "tutorial.html#conventional-superconductor",
    "title": "Bodge tutorial",
    "section": "Conventional superconductor",
    "text": "Conventional superconductor\nLet’s now consider a two-dimensional conventional (BCS) superconductor, which has an \\(s\\)-wave singlet order parameter \\(Δ_s\\). In this case, we want to consider a medium-large \\(101\\times101\\) lattice, but are only interested in the density of states in a narrow energy range around the “superconducting gap” at the Fermi level – since this is the part of the energy spectrum that is relevant for most transport phenomena.\nConventional superconductors can be described by a Hamiltonian operator \\(\\mathcal{H} = \\mathcal{H}_N + \\mathcal{H}_S\\) that contain both the normal-metal contributions \\(\\mathcal{H}_N\\) described under normal metal and an additional pairing term \\[\\mathcal{H}_S = -\\sum_{i\\sigma\\sigma'} c^\\dagger_{i\\sigma} (\\Delta_s i\\sigma_2)_{\\sigma\\sigma'} c^\\dagger_{i\\sigma'} + \\text{h.c.,}\\] where \\(\\Delta_s\\) is a complex number that can in general be a function of position. The matrix \\(i\\sigma_2\\) simply produces a spin structure of the form \\(\\uparrow\\downarrow - \\downarrow\\uparrow\\), which is appropriate for a spin-singlet state.\nTo model this using Bodge, we simply use a with system as (H, Δ) block to access the Hamiltonian object, and set the on-site terms Δ[i, i] to the contents \\(\\Delta_s i\\sigma_2\\) of the parentheses above:\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfrom bodge import *\n\n# Model parameters\nLx = 201\nLy = 201\n\nt = 1\nμ = -3 * t\nΔs = 0.2 * t\n\n# Construct the Hamiltonian\nlattice = CubicLattice((Lx, Ly, 1))\nsystem = Hamiltonian(lattice)\n\nwith system as (H, Δ):\n    for i in lattice.sites():\n        H[i, i] = -μ * σ0\n        Δ[i, i] = -Δs * jσ2\n    for i, j in lattice.bonds():\n        H[i, j] = -t * σ0\n\n# Calculate the density of states\ni = (Lx//2, Ly//2, 0)\nω = np.linspace(-1.5 * Δs, 1.5 * Δs, 101)\nρ = system.ldos(i, ω)\n\n# Plot the results\nplt.figure()\nplt.xlabel(\"Quasiparticle energy ω/t\")\nplt.ylabel(\"Density of states ρ(ω)\")\nplt.plot(ω, ρ)\n\n\n\n\n\n\n\n\nThe rest of the code is the same as for the normal metal. We correctly get a “superconducting gap” of width \\(2Δ_s\\) at the Fermi level \\(\\omega=0\\).\nIt is also quite straight-forward if you want to consider a current-carrying superconductor: you just need to introduce a complex phase winding into the superconducting gap. For instance, to get one full phase winding across the system along the \\(x\\) direction, we can let \\(\\Delta_s \\to \\Delta_s e^{2 \\pi i x/L_x}\\). To ensure that charge current is conserved at the system’s edges, you may however want to turn on periodic boundary conditions as well. Bodge can facilitate this using another iterator lattice.edges(), which returns pairs of lattice sites (i, j) on opposite ends of the lattice so that we can add hopping terms that “wrap around” the lattice. This is usually a decent model for the behavior of a large bulk superconductor with an applied electric current:\n\nwith system as (H, Δ):\n    for i in lattice.sites():\n        Δi = Δs * np.exp(2*π*1j*i[0]/Lx)\n        H[i, i] = -μ * σ0\n        Δ[i, i] = -Δi * jσ2\n    for i, j in lattice.bonds():\n        H[i, j] = -t * σ0\n    for i, j in lattice.edges():\n        H[i, j] = -t * σ0"
  },
  {
    "objectID": "tutorial.html#unconventional-superconductors",
    "href": "tutorial.html#unconventional-superconductors",
    "title": "Bodge tutorial",
    "section": "Unconventional superconductors",
    "text": "Unconventional superconductors\nIn unconventional superconductors, the electrons that form a Cooper pair reside on different lattice sites. Moreover, they often have a complex dependence on directionality, such that pairing terms along different cardinal axes on the lattice have different complex phases. Generally, this kind of pairing term contributes as follows to the Hamiltonian: \\[\\mathcal{H}_S = -\\sum_{\\langle ij \\rangle \\sigma\\sigma'} c^\\dagger_{i\\sigma} (\\Delta_{ij})_{\\sigma\\sigma'} c^\\dagger_{j\\sigma'} + \\text{h.c.,}\\] where we have to specify some pairing function \\(\\Delta_{ij}\\).\nOne example of such a state is a “\\(d\\)-wave singlet superconductor”, which describes e.g. high-temperature cuprates. This can be modeled as: \\[\\Delta_{ij} = \\begin{cases} -\\Delta_d i\\sigma_2 & \\text{if $i, j$ are neighbors along the $x$ axis,}\\\\ +\\Delta_d i\\sigma_2 & \\text{if $i, j$ are neighbors along the $y$ axis.}\\end{cases}\\] Implementing this kind of system in Bodge is straight-forward:\n\nΔd = 0.1 * t\nwith system as (H, Δ):\n    for i, j in lattice.bonds():\n        H[i, j] = -t * σ0\n    for i, j in lattice.bonds(axis=0):\n        Δ[i, j] = -Δd * jσ2\n    for i, j in lattice.bonds(axis=1):\n        Δ[i, j] = +Δd * jσ2\n\nFor “\\(p\\)-wave triplet superconductors”, the pairing \\(\\Delta_{ij}\\) can become very complicated due to the many different degrees of freedom involved. In the literature, this is often described in terms of a \\(d\\)-vector: \\(\\Delta_{ij} = [\\mathbf{d}(\\mathbf{p})\\cdot\\boldsymbol{\\sigma}]i\\sigma_2\\) where \\(\\mathbf{d}(\\mathbf{p})\\) is a linear-in-momentum function that describes the spin dependence. Bodge can take in a \\(d\\)-vector expression like e.g. \\(\\mathbf{d}(\\mathbf{p}) = \\mathbf{e}_z p_x\\) and construct the correct matrix expression for \\(\\Delta_{ij}\\) for you. Here is an example:\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfrom bodge import *\n\n# Model parameters\nLx = 101\nLy = 101\n\nt = 1\nμ = -3 * t\nΔp = 0.3 * t\n\n# Construct the Hamiltonian\nlattice = CubicLattice((Lx, Ly, 1))\nsystem = Hamiltonian(lattice)\n\nσp = pwave(\"e_z * p_x\")\n\nwith system as (H, Δ):\n    for i in lattice.sites():\n        H[i, i] = -μ * σ0\n    for i, j in lattice.bonds():\n        H[i, j] = -t * σ0\n        Δ[i, j] = -Δp * σp(i, j)\n\n# Calculate the density of states\ni = (Lx//2, Ly//2, 0)\nω = np.linspace(-1.5 * Δp, 1.5 * Δp, 101)\nρ = system.ldos(i, ω)\n\n# Plot the results\nplt.figure()\nplt.xlabel(\"Quasiparticle energy ω/t\")\nplt.ylabel(\"Density of states ρ(ω)\")\nplt.plot(ω, ρ)\n\n\n\n\n\n\n\n\nMore complex \\(d\\)-vector expressions are also possible; for instance, you can use pwave(\"(e_x + je_y) * (p_x + jp_y) / 2\") to get a non-unitary chiral \\(p\\)-wave state. The main “rule” is that you need to write the \\(d\\)-vector in a form where all the unit vectors \\(\\{ \\mathbf{e}_x, \\mathbf{e}_y, \\mathbf{e}_z \\}\\) are written to the left of the momentum variables \\(\\{ p_x, p_y, p_z \\}\\). The algorithm used in pwave is described in Sec. II-B of this paper.\nIn addition to the pwave function, Bodge provides a dwave function for modeling \\(d_{x^2-y^2}\\) superconductors and an swave function for consistency. However, for singlet superconductors, you may find it easier to encode the tight-binding model “manually” as shown above."
  },
  {
    "objectID": "tutorial.html#magnetic-materials",
    "href": "tutorial.html#magnetic-materials",
    "title": "Bodge tutorial",
    "section": "Magnetic materials",
    "text": "Magnetic materials\nLet us now consider a superconductor exposed to a strong magnetic field, where the Zeeman effect can result in a spin splitting. Alternatively, the same physics would arise in e.g. superconductor/ferromagnet bilayers, and Bodge can model these as well (you just need some simple if tests to determine which fields apply to which lattice sites).\nMagnetism can be modeled by introducing a spin-dependent term \\(-\\mathbf{M} \\cdot \\boldsymbol{\\sigma}\\) into the on-site Hamiltonian \\(H_{ii}\\). In the simple case \\(\\mathbf{M} = M_z \\mathbf{e}_z\\) of a homogeneous magnetic field, we are simply left with a term \\(-M_z \\sigma_3\\) in the Hamiltonian. Modifying the code for the conventional superconductor, we get:\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfrom bodge import *\n\n# Model parameters\nLx = 201\nLy = 201\n\nt = 1\nμ = -3.0 * t\nΔs = 0.20 * t\nMz = 0.25 * Δs\n\n# Construct the Hamiltonian\nlattice = CubicLattice((Lx, Ly, 1))\nsystem = Hamiltonian(lattice)\n\nwith system as (H, Δ):\n    for i in lattice.sites():\n        H[i, i] = -μ * σ0 - Mz * σ3\n        Δ[i, i] = -Δs * jσ2\n    for i, j in lattice.bonds():\n        H[i, j] = -t * σ0\n\n# Calculate the density of states\ni = (Lx//2, Ly//2, 0)\nω = np.linspace(-1.5 * Δs, 1.5 * Δs, 101)\nρ = system.ldos(i, ω)\n\n# Plot the results\nplt.figure()\nplt.xlabel(\"Quasiparticle energy ω/t\")\nplt.ylabel(\"Density of states ρ(ω)\")\nplt.plot(ω, ρ)\n\n\n\n\n\n\n\n\nWe see that the presence of magnetism causes the well-known “spin splitting” of the density of states, where the sharp peaks at \\(\\omega = \\pm\\Delta_s\\) are split in two. The strength of this splitting is given by \\(M_z\\).\nOther forms of spin-dependence are also easily implemented in Bodge:\n\nFerromagnetic domain walls can be implemented by setting H[i, i] = -Mx(i) * σ1 - My(i) * σ2 - Mz(i) * σ3 for arbitrary functions \\(\\{M_x(i), M_y(i), M_z(i)\\}\\) that depend on the lattice sites \\(i = (x_i, y_i, z_i)\\).\nAntiferromagnetism can be modeled by letting the spin alternate from site to site. For instance, H[i, i] = -Mz * σ3 * (-1)**sum(i) would create a “checkerboard-patterned” antiferromagnet.\nAltermagnetism and spin-orbit coupling can be modeled by having spin-dependent hopping terms instead of spin-dependent on-site terms. For instance, you can let H[i, j] = -t * σ0 -m * σ3."
  },
  {
    "objectID": "tutorial.html#footnotes",
    "href": "tutorial.html#footnotes",
    "title": "Bodge tutorial",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nExamples: Vim has built-in “digraphs” where you can press &lt;C-k&gt;s* in insert mode to type σ. Emacs has a built-in “TeX input method”, which means that after pressing C-\\ you can type \\sigma to insert the symbol σ. Most other editors code have third-party plugins for this, e.g. Unicode Latex for VSCode. Another option is to use an OS-wide snippet expander (e.g. TextExpander), which you can setup to e.g. convert ;s to a in any application. Another alternative is to just enable a Greek keyboard layout in your OS settings, with a hotkey to switch between the layouts. There are many alternatives!↩︎"
  }
]