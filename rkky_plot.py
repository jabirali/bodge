#!/usr/bin/env python

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns
from icecream import ic
from typer import run

np.set_printoptions(formatter={"float": "{: 0.12f}".format})
sns.set_style("darkgrid")


def free_energy(df: pd.DataFrame, s1: int, s2: int):
    """Calculate the free energy for a given configuration of two impurity spins.

    The spins are assumed to be specified as {±1, ±2, ±3} for the three cardinal
    axes, which is translated to the notations {x±, y±, z±} used in data files.
    If data is missing for any of the spin configurations, we just return NaN.
    """
    spins = {
        +1: "x+",
        +2: "y+",
        +3: "z+",
        -1: "x-",
        -2: "y-",
        -3: "z-",
    }

    s1_ = spins[s1]
    s2_ = spins[s2]

    try:
        return float(df[(df["s1"] == s1_) & (df["s2"] == s2_)].E)
    except:
        return np.nan


def effective_energy(df: pd.DataFrame):
    """Calculate the couplings in the effective free energy for the two spins.

    This includes a Heisenberg-like J, Dzyaloshinskii-Moriya-like D, preferred
    spin orientation μ for each impurity, and the spin-averaged free energy ε0.
    """
    results = []
    for (d, δ), df_ in df.groupby(["dvec", "sep"]):
        ic(d)
        ic(δ)

        # Calculate spin-independent free energy (rank 0).
        ε0 = 0.0
        for s1 in [+1, +2, +3, -1, -2, -3]:
            for s2 in [+1, +2, +3, -1, -2, -3]:
                ε0 += free_energy(df_, s1, s2) / 36

        ic(ε0)

        # Calculate the preferred orientation of each spin (rank 1).
        μ1 = np.zeros(3)
        μ2 = np.zeros(3)
        μ = np.zeros(3)

        for i1, s1 in enumerate([1, 2, 3]):
            for s2 in [+1, +2, +3, -1, -2, -3]:
                μ1[i1] += free_energy(df_, +s1, s2) / 12
                μ1[i1] -= free_energy(df_, -s1, s2) / 12
        for i2, s2 in enumerate([1, 2, 3]):
            for s1 in [+1, +2, +3, -1, -2, -3]:
                μ2[i2] += free_energy(df_, s1, +s2) / 12
                μ2[i2] -= free_energy(df_, s1, -s2) / 12
        for i, s in enumerate([1, 2, 3]):
            μ[i] += free_energy(df_, +s, +s) / 4
            μ[i] -= free_energy(df_, -s, -s) / 4

        ic(μ1)
        ic(μ2)
        ic(μ)

        # Calculate the interactions between the two spins (rank 2).
        η = np.zeros((3, 3))
        for i1, s1 in enumerate([1, 2, 3]):
            for i2, s2 in enumerate([1, 2, 3]):
                η[i1, i2] += free_energy(df_, +s1, +s2) / 4
                η[i1, i2] -= free_energy(df_, +s1, -s2) / 4
                η[i1, i2] -= free_energy(df_, -s1, +s2) / 4
                η[i1, i2] += free_energy(df_, -s1, -s2) / 4

        # ic(η)

        # Calculate the Heisenberg-like interaction.
        J = np.zeros(3)
        for i in range(3):
            J[i] = η[i, i]

        ic(J)

        # Calculate the Dzyaloshinskii-Moriya-like interaction.
        D = np.zeros(3)
        for i in range(3):
            j = (i + 1) % 3
            k = (i + 2) % 3
            D[i] = (η[j, k] - η[k, j]) / 2

        ic(D)

        # Save the effective couplings in the free energy.
        results.append(
            {
                "d": d,
                "δ": δ,
                "ε0": ε0,
                "μx": μ[0],
                "μy": μ[1],
                "μz": μ[2],
                "Jx": J[0],
                "Jy": J[1],
                "Jz": J[2],
                "Dx": D[0],
                "Dy": D[1],
                "Dz": D[2],
            }
        )

    # Construct a dataframe out of the results.
    return pd.DataFrame(results)


def plot(df: pd.DataFrame, ax, var: str, legend=False):
    """Plot a particular effective energy coupling as function of separation."""
    sns.lineplot(data=df, ax=ax, x="δ", y=var, hue="d", legend=legend)


def main(filename: str):
    """Plot the results generated by RKKY calculations."""

    # Load simulation results.
    df = pd.read_csv(filename, names=["dvec", "s1", "s2", "sep", "E"], skipinitialspace=True)
    df = df.sort_values(by=["dvec", "sep", "s1", "s2"])
    ic(df)

    # Postprocess results.
    df = effective_energy(df)
    ic(df)

    # Visualize the results.
    _, ax = plt.subplots()
    plot(df, ax, "ε0", legend=True)
    ax.set_xlabel(r"Distance $δ/a$")
    ax.set_ylabel(rf"Spin-independent energy $E_0/t$")

    _, ax = plt.subplots(1, len(df.d.unique()), sharey="row", sharex="all")
    for i, (d, df_) in enumerate(df.groupby("d")):
        ax[i].plot(df_.δ, df_.Jx, label="Jx")
        ax[i].plot(df_.δ, df_.Jy, label="Jy")
        ax[i].plot(df_.δ, df_.Jz, label="Jz")
        ax[i].set_ylabel("")
        ax[i].set_ylim([-0.001, 0.001])
        ax[i].set_xlabel(r"Distance $δ/a$")
        ax[i].set_title(d)
        plt.legend()

    _, ax = plt.subplots(3, 3, sharey="row", sharex="all")
    for i, axis in enumerate(["x", "y", "z"]):
        plot(df, ax[0, i], f"μ{axis}", legend=i == 1)
        ax[0, i].set_xlabel(r"Distance $δ/a$")
        ax[0, i].set_ylabel("")
        ax[0, i].set_title(rf"$μ_{axis}/t$")
        # ax[0, i].set_ylim([-0.00000001, 0.00000001])
        ax[0, i].ticklabel_format(scilimits=(-1, 3))

    for i, axis in enumerate(["x", "y", "z"]):
        plot(df, ax[1, i], f"J{axis}")
        ax[1, i].set_xlabel(r"Distance $δ/a$")
        ax[1, i].set_ylabel("")
        ax[1, i].set_title(rf"$J_{axis}/t$")
        ax[1, i].set_ylim([-0.001, 0.001])
        ax[1, i].ticklabel_format(scilimits=(-1, 3))

    for i, axis in enumerate(["x", "y", "z"]):
        plot(df, ax[2, i], f"D{axis}")
        ax[2, i].set_xlabel(r"Distance $δ/a$")
        ax[2, i].set_ylabel("")
        ax[2, i].set_title(rf"$D_{axis}/t$")
        # ax[2, i].set_ylim([-0.00001, 0.00001])
        ax[2, i].ticklabel_format(scilimits=(-1, 3))

    ax[0, 0].set_xlim([0, 40])

    plt.show()


if __name__ == "__main__":
    run(main)
